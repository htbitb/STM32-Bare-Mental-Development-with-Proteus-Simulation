## What is I2C?
It is just a protocol to achieve serial data communication between integrated circuits(ICs) which are very close to each other. (but more serious protocol than SPI because companies have come forward to design a specification)

I2C protocol details (how data should sent, how data should received, how hand shaking should happen between sender and receiver, error handling) are complex than SPI.. (In other words SPI is simple protocol compared to I2C)


## How different than SPI?
- I2C protocol is multi-master capable, whereas SPI has no guilines to achieve this, but depends on MCU designers. STM SPI peripherals can be used in multi master configurations but arbitration should be handled by software code.

- I2C hardware automatically ACKs every byte received. SPI does not support any automatic ACKing.

- I2C needs just 2 pins for communication whereas SPI may need 4 pins and even more than that it multiple slaves are involved

- I2C master talk to slaves based on slave addresses, whereas in SPI dedicated pin is used to select the slave

- I2C is half duplex, where us SPI is full duplex

- For I2C the max speed is 4MHz in ultra speed plus. for some STM the max speed is just 400KHz. SPI is Fpclk/2.

- In I2C slave can make master wait by holding the clock down if it's busy, thanks to clock stretching feature of I2C. But in SPI, slave has no control over clock, programmers may use their own tricks to overcome this situation

## Data Rate
Data rate (number of bits transferred from sender to receiver in 1 sec) is much lesser in I2C compared to SPI.

For example in STM32F4X if you have peripheral clocks of 40MHz, then in I2C you can achieve data rate of 400Kbps but in SPI it is 20Mbps

So in the above scenario SPI is 50 times faster than I2C


![alt text](picture\image.png)


## SDA and SCL signals

![alt text](picture\image-1.png)

- Both SDA and SCL are bidirectional lines connected to a positive supply voltage via pull-up resistors. when the bus is free, both lines are held at HIGH

- The output stages of devices connected tp the bus must have an open-drain or open-collector configuration

- The bus capacitance limits the number of interfaces connected to the bus.

TIP: Whenever you face problems in I2C, probe  the SDA and SCL line after I2C initialization. It must be held at HIGH (3.3V or 18V depending up on IO voltage level of your boards)

## I2C Protocol Explanation
- Every byte put on the SDA line must be eights bits long
- Each byte must be followed by an Acknowledge Bit
- Data is transferred with the Most Significant Bit (MSB) first
- R/W='1' indicates request for data (READ) 

#### Start and stop conditions 
- All transactions begin with a start (S) and are terminated by a STOP (P)
- A HIGH to LOW transaction on the SDA line while SCL is HIGH defines a START condition.
- A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.

![alt text](picture\image-2.png)

- START and STOP conditions are always generated by the master. The bus is considered to be busy after the START condition
- The bus is considered to be free again a certain time after the STOP condition
- When the bus is free another master (if present) can get the chance to claim the bus
- The bus stays busy if a repeated START (Sr) is generated instead of a STOP condition
- Most of the MCU's I2C peripherals support both master and slave mode. you need not to configure the mode because when the peripheral generates the start condition it automatically becomes the master and when it generates the stop condition it goes back to slave mode

#### Adress Phase
**ACK**

The Acknowledge signal is defined as follows:
- the transmitter releases the SDA line during the acknowledge clock pulse so the receiver can pull the SDA line LOW and it remains stable LOW during the HIGH period of this clock.
- The acknowledge takes place after every byte
- The acknowledge bit allows the receiver to signal the transmitter that the byte was successfully received and another byte may be sent
- The master generates all clock pulses, including the acknowledge ninth clock pulse

**Data Validity**

The data on SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW. One clock pulse is generated for each data bit transferred.

![alt text](picture\image-3.png)


**I2C Clock Stretching**
- Clock Stretching simply means that holsing the clock to 0 o ground level.
- The moment clock is held at low, then the hold  I2C interface pauses until clock
- I2C devices, either Master or Slave, uses this feature to slow down communication by stretching SCL to low, which prevents the clock to Rise high again and the I2C communication stops for a while
- There are situations where an I2C slave is not able to co-operate with the clock speed given by the master and needs to slow down a little
- if slave needs time, then it takes the advantage of clock stretching, and by holding clock at low, it momentary pauses the I2C operation.

### I2C Transfer sequence

![alt text](picture\image-4.png)

![alt text](picture\image-5.png)

### I2C error and importance of BUSY flag
**Bus Error**: This error happens when the interface detects an SDA rising or falling edge while SCL is high, occurring in a non-valid position during a byte transfer

**Arbitration Loss Error**: this error can happend when the interface loses the arbitration of the bus to another master

**ACK failure**: this error happens when no ACK is returned for the byte sent

**Overrun Error**: Happens during reception, when a new byte is received and tha data register has not been read yet and the New received byte is lost.

**Under-run Error**: Happens when in transmission when a new byte should be sent and the data register has not been written yet and the same byte is sent twice.
- In the I2C the overrun and underrun will not happen if clock stretching is enabled be cause in those conditions the clock will be helped LOW and both communicating devices will enter the wait state.

**PEC error**: Happens when there is CRC mismatch, if you have enabled the CRC feature.

**Time-ot Error**: Happens when master ir slave stretches the clock, by holding it low more than recommend amount of time.

#### BTF flag in TX and preventing underrun
During Txing of a data byte, if TXE=1, then that means data register is empty

And if the firmware has not written any byte to data register before shift register becomes empty(previous byte transmission), then BTF flag will be set and clock will be stretched to prevent the under run

#### BTF flag in RX and preventing overrun
if RXNE = 1, then it means new data is waiting in the data register, and if the firmware has not read the data byte yet before shift register is filled with another new data, then also the BTF flag will be set and clock will be stretched to prevent the overrun.


### Common Problems in I2C and debugging Tips
**Mandatory Tip**: Whenever you face problems in I2C, probe the SDA and SLA line after I2C initialization. it must be held at HIGH Voltage.

#### Problem 1: SDA and SCL line not held HIGH Voltage after I2C pin initialization
**reason 1**: Not activating the pullup registors if you are using the internal pull up resistor of an I/o line

**Debug Tip**: worth checking the configuration register of an I/O line to see whether the pull ups are really activated or not, best way is to dump the register contents

#### Problem 2: ACK failure
**Reason**: Not enabling the ACKing feature in the I2C control register

**Debug tip**: Cross check the I2C control register ACK enable field

#### Problem 3: Master is not producing the clock 
**Debug Tip 1**: First check whether I2C peripheral clock is enabled and set to at least 2mhz to procedure standard mode i2c clock frequency

**Debug Tp 2**: Check whether GPIOs which you used for SCL and SDA functionality are configured properly for the alternate functionality.